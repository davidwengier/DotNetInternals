@page "/"
@inject NavigationManager navigationManager
@using Blazored.LocalStorage
@using DotNetInternals.RazorAccess
@using System.Diagnostics.CodeAnalysis
@inject IJSRuntime JSRuntime;
@inject ILocalStorageService LocalStorage;

<PageTitle>Razor • DotNetInternals</PageTitle>

<div class="d-flex flex-column h-100">
    <div class="row align-items-center justify-content-center mb-2">
        @* Compile button *@
        <div class="col-auto">
            <button type="button" class="btn btn-primary" @onclick="Compile">
                Compile
                @if (compilationInProgress)
                {
                    <div class="spinner-border spinner-border-sm ms-2" role="status">
                        <span class="visually-hidden">Compiling...</span>
                    </div>
                }
            </button>
        </div>

        @* Output switch *@
        <InputRadioGroup @bind-Value="SelectedOutputType">
            <div class="btn-group col-auto" role="group" aria-label="Output type">
                <InputRadio class="btn-check" id="outputSyntax" Value="OutputType.Syntax" />
                <label class="btn btn-outline-primary" for="outputSyntax">
                    Syntax
                </label>

                <InputRadio class="btn-check" id="outputIr" Value="OutputType.Ir" />
                <label class="btn btn-outline-primary" for="outputIr">
                    IR
                </label>

                <InputRadio class="btn-check" id="outputCSharp" Value="OutputType.CSharp" />
                <label class="btn btn-outline-primary" for="outputCSharp">
                    C#
                </label>

                <InputRadio class="btn-check" id="outputDiagnostics" Value="OutputType.Diagnostics" />
                <label class="btn btn-outline-primary" for="outputDiagnostics">
                    Diagnostics
                    @if (compiled?.NumErrors > 0)
                    {
                        <span class="badge bg-danger">@compiled.NumErrors</span>
                    }
                    else if (compiled?.NumWarnings > 0)
                    {
                        <span class="badge bg-warning">@compiled.NumWarnings</span>
                    }
                </label>
            </div>
        </InputRadioGroup>

        @* Toggles *@
        <div class="col-auto">
            <div class="form-check">
                <input class="form-check-input" type="checkbox" id="wordWrap" @bind="wordWrap" @bind:after="WordWrapChanged" />
                <label class="form-check-label" for="wordWrap">
                    Word wrap
                </label>
            </div>
            <div class="form-check">
                <input class="form-check-input" type="checkbox" id="vim" @bind="useVim" @bind:after="VimChanged" />
                <label class="form-check-label" for="vim">
                    Use VIM
                </label>
            </div>
        </div>
    </div>

    @* Input / output text areas *@
    @{
        var textAreaClass = $"form-control h-100 flex-grow-1 {(wordWrap ? "" : "no-wrap")}";
    }
    <div class="row g-2 flex-grow-1">
        <div class="col-12 col-md flex-grow-1 d-flex flex-column overflow-hidden">
            <div id="vim-status" class="vim-status-bar" hidden="@(!useVim)" />
            <BlazorMonaco.Editor.StandaloneCodeEditor CssClass="flex-grow-1 overflow-auto" @ref="razorCode" Id="razor-code" ConstructionOptions="EditorConstructionOptions" />
        </div>
        <div class="col-12 col-md">
            <textarea @bind="output" class="@textAreaClass" readonly placeholder="Empty output (click Compile to refresh)" spellcheck="false"></textarea>
        </div>
    </div>
</div>

@code {
    private IJSObjectReference? vimDisposable;
    private StandaloneCodeEditor razorCode = null!;
    private OutputType _outputType = OutputType.CSharp;
    private bool compilationInProgress;
    private CompiledRazor? compiled;
    private string output = "";
    private bool wordWrap;
    private bool useVim;

    private StandaloneEditorConstructionOptions EditorConstructionOptions(StandaloneCodeEditor editor)
    {
        return new StandaloneEditorConstructionOptions
            {
                WordWrap = wordWrap ? "on" : "off",
                Language = "razor",
                Value = RazorCompiler.InitialCode
            };
    }

    private async Task WordWrapChanged()
    {
        await RefreshAsync();
        await LocalStorage.SetItemAsync(nameof(wordWrap), wordWrap);
        await razorCode.UpdateOptions(new EditorUpdateOptions { WordWrap = wordWrap ? "on" : "off" });
    }

    private async Task VimChanged()
    {
        await RefreshAsync();
        await LocalStorage.SetItemAsync(nameof(useVim), useVim);
        if (useVim)
        {
            if (vimDisposable is null)
            {
                vimDisposable = await JSRuntime.InvokeAsync<IJSObjectReference>("jslib.EnableVimMode", "razor-code", "vim-status");
            }
        }
        else
        {
            if (vimDisposable is not null)
            {
                await vimDisposable.InvokeVoidAsync("dispose");
                vimDisposable = null;
            }
        }

        await razorCode.Layout();
    }

    protected override void OnInitialized()
    {
        var uri = navigationManager.ToAbsoluteUri(navigationManager.Uri);
        var slug = uri.Fragment.TrimStart('#');

        text = string.IsNullOrWhiteSpace(slug)
            ? RazorCompiler.InitialCode
            : Compressor.Uncompress(slug);
    }

    private OutputType SelectedOutputType
    {
        get => _outputType;
        set
        {
            _outputType = value;
            UpdateOutput();
        }
    }

    private async Task Compile()
    {
        compilationInProgress = true;
        await RefreshAsync();
        compiled = RazorCompiler.Compile(await razorCode.GetValue());
        UpdateOutput();

        var slug = Compressor.Compress(text);
        navigationManager.NavigateTo(navigationManager.BaseUri + "#" + slug, forceLoad: false);
        
        compilationInProgress = false;
    }

    private async Task RefreshAsync()
    {
        _ = InvokeAsync(StateHasChanged);
        await Task.Yield();
    }

    private void UpdateOutput()
    {
        output = SelectedOutputType switch
        {
            _ when compiled is null => "",
            OutputType.Syntax => compiled.Syntax,
            OutputType.Ir => compiled.Ir,
            OutputType.CSharp => compiled.CSharp,
            OutputType.Diagnostics => compiled.Diagnostics,
            _ => throw new InvalidOperationException(),
        };
    }

    private enum OutputType
    {
        Syntax,
        Ir,
        CSharp,
        Diagnostics,
    }

    protected override async Task OnInitializedAsync()
    {
        if (await LocalStorage.ContainKeyAsync(nameof(wordWrap)))
        {
            wordWrap = await LocalStorage.GetItemAsync<bool>(nameof(wordWrap));
        }
        if (await LocalStorage.ContainKeyAsync(nameof(useVim)))
        {
            useVim = await LocalStorage.GetItemAsync<bool>(nameof(useVim));
            await VimChanged();
        }

        await base.OnInitializedAsync();
    }
}
